/// <reference path="../localtypings/pxtblockly.d.ts" />
/// <reference path="pxtlib.d.ts" />
/// <reference path="../localtypings/blockly.d.ts" />
import B = Blockly;
declare let iface: pxt.worker.Iface;
declare namespace pxt.blocks {
    function workerOpAsync(op: string, arg: pxtc.service.OpArg): Promise<any>;
    class Point {
        link: Point;
        type: string;
        parentType: Point;
        childType: Point;
        constructor(link: Point, type: string, parentType?: Point, childType?: Point);
    }
    function compileExpression(e: Environment, b: B.Block, comments: string[]): JsNode;
    interface Environment {
        workspace: Blockly.Workspace;
        bindings: Binding[];
        stdCallTable: pxt.Map<StdFunc>;
        errors: B.Block[];
        renames: RenameMap;
        stats: pxt.Map<number>;
    }
    interface RenameMap {
        oldToNew: Map<string>;
        takenNames: Map<boolean>;
        oldToNewFunctions: Map<string>;
    }
    enum VarUsage {
        Unknown = 0,
        Read = 1,
        Assign = 2,
    }
    interface Binding {
        name: string;
        type: Point;
        declaredInLocalScope: number;
        assigned?: VarUsage;
        mustBeGlobal?: boolean;
    }
    function escapeVarName(name: string, e: Environment, isFunction?: boolean): string;
    interface StdFunc {
        f: string;
        comp: BlockCompileInfo;
        attrs: ts.pxtc.CommentAttrs;
        isExtensionMethod?: boolean;
        isExpression?: boolean;
        imageLiteral?: number;
        hasHandler?: boolean;
        property?: boolean;
        namespace?: string;
        isIdentity?: boolean;
    }
    function mkEnv(w: B.Workspace, blockInfo?: pxtc.BlocksInfo, skipVariables?: boolean): Environment;
    function compileBlockAsync(b: B.Block, blockInfo: pxtc.BlocksInfo): Promise<BlockCompilationResult>;
    function callKey(e: Environment, b: B.Block): string;
    interface BlockCompilationResult {
        source: string;
        sourceMap: SourceInterval[];
        stats: pxt.Map<number>;
    }
    function findBlockId(sourceMap: SourceInterval[], loc: {
        start: number;
        length: number;
    }): string;
    function compileAsync(b: B.Workspace, blockInfo: pxtc.BlocksInfo): Promise<BlockCompilationResult>;
}
declare namespace pxt.blocks {
    function initFieldEditors(): void;
    function registerFieldEditor(selector: string, field: Blockly.FieldCustomConstructor, validator?: any): void;
    function createFieldEditor(selector: string, text: string, params: any): Blockly.FieldCustom;
}
declare namespace pxt.blocks {
    function saveWorkspaceXml(ws: Blockly.Workspace): string;
    function getDirectChildren(parent: Element, tag: string): Element[];
    function getBlocksWithType(parent: Document | Element, type: string): Element[];
    function getChildrenWithAttr(parent: Document | Element, tag: string, attr: string, value: string): Element[];
    function getFirstChildWithAttr(parent: Document | Element, tag: string, attr: string, value: string): Element;
    /**
     * Loads the xml into a off-screen workspace (not suitable for size computations)
     */
    function loadWorkspaceXml(xml: string, skipReport?: boolean): B.Workspace;
    function importXml(xml: string, info: pxtc.BlocksInfo, skipReport?: boolean): string;
    /**
     * Convert blockly hue to rgb
     */
    function convertColour(colour: string): string;
}
declare namespace pxt.blocks.layout {
    interface FlowOptions {
        ratio?: number;
        useViewWidth?: boolean;
    }
    function patchBlocksFromOldWorkspace(blockInfo: ts.pxtc.BlocksInfo, oldWs: B.Workspace, newXml: string): string;
    function verticalAlign(ws: B.Workspace, emPixels: number): void;
    function flow(ws: B.Workspace, opts?: FlowOptions): void;
    function screenshotEnabled(): boolean;
    function screenshotAsync(ws: B.Workspace): Promise<string>;
    function toPngAsync(ws: B.Workspace): Promise<string>;
    function svgToPngAsync(svg: SVGElement, x: number, y: number, width: number, height: number, pixelDensity: number): Promise<string>;
    function toSvgAsync(ws: B.Workspace): Promise<{
        width: number;
        height: number;
        xml: string;
    }>;
    function serializeNode(sg: Node): string;
    interface BlockSvg {
        width: number;
        height: number;
        svg: string;
        xml: string;
        css: string;
    }
    function blocklyToSvgAsync(sg: SVGElement, x: number, y: number, width: number, height: number): Promise<BlockSvg>;
    function documentToSvg(xsg: Node): string;
}
import Util = pxt.Util;
declare let lf: typeof pxtc.U.lf;
declare namespace pxt.blocks {
    const blockColors: Map<number | string>;
    const blockIcons: Map<number | string>;
    enum CategoryMode {
        All = 0,
        None = 1,
        Basic = 2,
    }
    function advancedTitle(): string;
    function addPackageTitle(): string;
    const optionalDummyInputPrefix = "0_optional_dummy";
    const optionalInputWithFieldPrefix = "0_optional_field";
    function isArrayType(type: string): boolean;
    const buildinBlockStatements: Map<boolean>;
    function blockSymbol(type: string): pxtc.SymbolInfo;
    function appendToolboxIconCss(className: string, i: string): void;
    function injectToolboxIconCss(): void;
    function appendNamespaceCss(namespace: string, color: string): void;
    function hasArrowFunction(fn: pxtc.SymbolInfo): boolean;
    interface BlockFilters {
        namespaces?: {
            [index: string]: FilterState;
        };
        blocks?: {
            [index: string]: FilterState;
        };
        defaultState?: FilterState;
    }
    enum FilterState {
        Hidden = 0,
        Visible = 1,
        Disabled = 2,
    }
    function createToolbox(blockInfo: pxtc.BlocksInfo, toolbox?: Element, showCategories?: CategoryMode, filters?: BlockFilters, extensions?: pxt.PackageConfig[]): Element;
    function initBlocks(blockInfo: pxtc.BlocksInfo, toolbox?: Element, showCategories?: CategoryMode, filters?: BlockFilters, extensions?: pxt.PackageConfig[]): Element;
    let cachedSearchTb: Element;
    let cachedSearchTbAll: Element;
    function initSearch(workspace: Blockly.Workspace, tb: Element, tbAll: Element, searchAsync: (searchFor: pxtc.service.SearchOptions) => Promise<pxtc.service.SearchInfo[]>, updateToolbox: (tb: Element) => void): void;
    function removeSearch(): void;
    function cleanBlocks(): void;
    function installHelpResources(id: string, name: string, tooltip: any, url: string, colour: string, colourSecondary?: string, colourTertiary?: string): void;
    let openHelpUrl: (url: string) => void;
    var onShowContextMenu: (workspace: Blockly.Workspace, items: Blockly.ContextMenu.MenuItem[]) => void;
    function getNamespaceColor(ns: string): string;
    function getNamespaceIcon(ns: string): string;
    function initFlyouts(workspace: Blockly.Workspace): void;
    function initExtensions(workspace: Blockly.Workspace, extensions: pxt.PackageConfig[], callBack?: (name: string) => void): void;
}
declare namespace pxt.blocks {
    /**
     * This interface defines the optionally defined functions for mutations that Blockly
     * will call if they exist.
     */
    interface MutatingBlock extends Blockly.Block {
        mutation: Mutation;
        mutationToDom(): Element;
        domToMutation(xmlElement: Element): void;
        compose(topBlock: Blockly.Block): void;
        decompose(workspace: Blockly.Workspace): Blockly.Block;
    }
    /**
     * Represents a mutation of a block
     */
    interface Mutation {
        /**
         * Get the unique identifier for this type of mutation
         */
        getMutationType(): string;
        /**
         * Compile the mutation of the block into a node representation
         */
        compileMutation(e: Environment, comments: string[]): JsNode;
        /**
         * Get a mapping of variables that were declared by this mutation and their types.
         */
        getDeclaredVariables(): pxt.Map<string>;
        /**
         * Returns true if a variable with the given name was declared in the mutation's compiled node
         */
        isDeclaredByMutation(varName: string): boolean;
    }
    namespace MutatorTypes {
        const ObjectDestructuringMutator = "objectdestructuring";
        const RestParameterMutator = "restparameter";
        const DefaultInstanceMutator = "defaultinstance";
    }
    function addMutation(b: MutatingBlock, info: pxtc.SymbolInfo, mutationType: string): void;
    function mutateToolboxBlock(block: Node, mutationType: string, mutation: string): void;
}
declare namespace pxt.blocks {
    enum BlockLayout {
        Align = 1,
        Clean = 3,
        Flow = 4,
    }
    interface BlocksRenderOptions {
        emPixels?: number;
        layout?: BlockLayout;
        clean?: boolean;
        aspectRatio?: number;
        packageId?: string;
        package?: string;
        snippetMode?: boolean;
        useViewWidth?: boolean;
    }
    function render(blocksXml: string, options?: BlocksRenderOptions): SVGSVGElement;
    function blocksMetrics(ws: Blockly.Workspace): {
        width: number;
        height: number;
    };
}
declare namespace pxt.docs.codeCard {
    interface CodeCardRenderOptions {
        hideHeader?: boolean;
        shortName?: boolean;
    }
    function render(card: pxt.CodeCard, options?: CodeCardRenderOptions): HTMLElement;
}
declare namespace pxt.blocks {
    interface ComposableMutation {
        mutationToDom(mutationElement: Element): Element;
        domToMutation(savedElement: Element): void;
    }
    function appendMutation(block: Blockly.Block, mutation: ComposableMutation): void;
    function initVariableArgsBlock(b: B.Block, handlerArgs: pxt.blocks.HandlerArg[]): void;
    function initExpandableBlock(b: Blockly.Block, def: pxtc.ParsedBlockDef, comp: BlockCompileInfo, toggle: boolean, addInputs: () => void): void;
}
declare namespace pxt.blocks {
    function initMathOpBlock(): void;
}
declare namespace pxtblockly {
    class FieldColorWheel extends Blockly.FieldSlider implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private channel_;
        /**
         * Class for a color wheel field.
         * @param {number|string} value The initial content of the field.
         * @param {Function=} opt_validator An optional function that is called
         *     to validate any constraints on what the user entered.  Takes the new
         *     text as an argument and returns either the accepted text, a replacement
         *     text, or null to abort the change.
         * @extends {Blockly.FieldNumber}
         * @constructor
         */
        constructor(value_: any, params: any, opt_validator?: Function);
        /**
         * Set the gradient CSS properties for the given node and channel
         * @param {Node} node - The DOM node the gradient will be set on.
         * @private
         */
        setBackground_(node: Element): void;
        setReadout_(readout: Element, value: string): void;
        createColourStops_(): string[];
        colorWheel(wheelPos: number, channel?: string): string;
        hsvFast(hue: number, sat: number, val: number): string;
        private hex(red, green, blue);
        private componentToHex(c);
    }
}
declare namespace pxtblockly {
    interface FieldColourNumberOptions extends Blockly.FieldCustomOptions {
        colours?: string;
        columns?: string;
        className?: string;
    }
    class FieldColorNumber extends Blockly.FieldColour implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        protected colour_: string;
        private colorPicker_;
        private className_;
        constructor(text: string, params: FieldColourNumberOptions, opt_validator?: Function);
        /**
         * Return the current colour.
         * @param {boolean} opt_asHex optional field if the returned value should be a hex
         * @return {string} Current colour in '#rrggbb' format.
         */
        getValue(opt_asHex?: boolean): string;
        /**
         * Set the colour.
         * @param {string} colour The new colour in '#rrggbb' format.
         */
        setValue(colour: string): void;
        showEditor_(): void;
    }
}
declare namespace pxtblockly {
    interface FieldGridPickerToolTipConfig {
        yOffset?: number;
        xOffset?: number;
    }
    interface FieldGridPickerOptions extends Blockly.FieldCustomDropdownOptions {
        columns?: string;
        maxRows?: string;
        width?: string;
        itemColour?: string;
        tooltips?: string;
        tooltipsXOffset?: string;
        tooltipsYOffset?: string;
        hasSearchBar?: boolean;
        hideRect?: boolean;
    }
    class FieldGridPicker extends Blockly.FieldDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private width_;
        private columns_;
        private maxRows_;
        private backgroundColour_;
        private itemColour_;
        private borderColour_;
        private tooltipConfig_;
        private tooltips_;
        private firstItem_;
        private menu_;
        private hasSearchBar_;
        private hideRect_;
        constructor(text: string, options: FieldGridPickerOptions, validator?: Function);
        /**
         * When disposing the grid picker, make sure the tooltips are disposed too.
         * @public
         */
        dispose(): void;
        /**
         * Create blocklyGridPickerRows and add them to table container
         * @param options
         * @param tableContainer
         */
        private populateTableContainer(options, tableContainer);
        /**
         * Add the tooltips and style the items
         * @param options
         * @param tableContainer
         */
        private createTooltips(options, tableContainer);
        /**
         * Whether or not to show a box around the dropdown menu.
         * @return {boolean} True if we should show a box (rect) around the dropdown menu. Otherwise false.
         * @private
         */
        shouldShowRect_(): boolean;
        /**
         * Selects menu item and closes gridpicker
         * @param item = the item to select
         */
        private selectItem(item);
        /**
         * Set the language-neutral value for this dropdown menu.
         * We have to override this from field.js because the grid picker needs to redraw the selected item's image.
         * @param {string} newValue New value to set.
         */
        setValue(newValue: string): void;
        /**
         * Closes the gridpicker.
         */
        private close();
        /**
         * Getter method
         */
        private getFirstItem();
        /**
         * Highlight first item in menu, de-select and de-highlight all others
         */
        private highlightFirstItem(tableContainerDom);
        /**
         * Scroll menu to item that equals current value of gridpicker
         */
        private highlightAndScrollSelected(tableContainer, scrollContainerDom);
        /**
         * Create a dropdown menu under the text.
         * @private
         */
        showEditor_(): void;
        private createRow(row, options);
        /**
         * Disposes the tooltip DOM elements.
         * @private
         */
        private disposeTooltips();
        /**
         * Sets the text in this field.  Trigger a rerender of the source block.
         * @param {?string} text New text.
         */
        setText(text: string): void;
        /**
         * Updates the width of the field. This calls getCachedWidth which won't cache
         * the approximated width on IE/Edge when `getComputedTextLength` fails. Once
         * it eventually does succeed, the result will be cached.
         **/
        updateWidth(): void;
        /**
         * Update the text node of this field to display the current text.
         * @private
         */
        updateTextNode_(): void;
    }
}
declare namespace pxtblockly {
    interface FieldImageDropdownOptions extends Blockly.FieldCustomDropdownOptions {
        columns?: string;
        maxRows?: string;
        width?: string;
        itemColour?: string;
    }
    class FieldImageDropdown extends Blockly.FieldDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private width_;
        private columns_;
        private maxRows_;
        private backgroundColour_;
        private itemColour_;
        private borderColour_;
        constructor(text: string, options: FieldImageDropdownOptions, validator?: Function);
        /**
         * Create a dropdown menu under the text.
         * @private
         */
        showEditor_(): void;
        /**
         * Callback for when a button is clicked inside the drop-down.
         * Should be bound to the FieldIconMenu.
         * @param {Event} e DOM event for the click/touch
         * @private
         */
        private buttonClick_;
        /**
         * Callback for when the drop-down is hidden.
         */
        private onHide_;
        /**
         * Sets the text in this field.  Trigger a rerender of the source block.
         * @param {?string} text New text.
         */
        setText(text: string): void;
        /**
         * Updates the width of the field. This calls getCachedWidth which won't cache
         * the approximated width on IE/Edge when `getComputedTextLength` fails. Once
         * it eventually does succeed, the result will be cached.
         **/
        updateWidth(): void;
        /**
         * Update the text node of this field to display the current text.
         * @private
         */
        updateTextNode_(): void;
    }
}
declare namespace pxtblockly {
    interface FieldNoteOptions extends Blockly.FieldCustomOptions {
        editorColour?: string;
        minNote?: string;
        maxNote?: string;
    }
    class FieldNote extends Blockly.FieldNumber implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private note_;
        private colour_;
        private colourBorder_;
        /**
         * default number of piano keys
         * @type {number}
         * @private
         */
        private nKeys_;
        private minNote_;
        private maxNote_;
        /**
         * Absolute error for note frequency identification (Hz)
         * @type {number}
         */
        eps: number;
        /**
         * array of notes frequency
         * @type {Array.<number>}
         * @private
         */
        private noteFreq_;
        /**
         * array of notes names
         * @type {Array.<string>}
         * @private
         */
        private noteName_;
        constructor(text: string, params: FieldNoteOptions, validator?: Function);
        /**
         * Ensure that only a non negative number may be entered.
         * @param {string} text The user's text.
         * @return {?string} A string representing a valid positive number, or null if invalid.
         */
        classValidator(text: string): string;
        /**
         * Install this field on a block.
         */
        init(): void;
        /**
         * Return the current note frequency.
         * @return {string} Current note in string format.
         */
        getValue(): string;
        /**
         * Set the note.
         * @param {string} note The new note in string format.
         */
        setValue(note: string): void;
        /**
         * Get the text from this field.  Used when the block is collapsed.
         * @return {string} Current text.
         */
        getText(): string;
        /**
         * Set the text in this field and NOT fire a change event.
         * @param {*} newText New text.
         */
        setText(newText: string): void;
        /**
        * get the note name to be displayed in the field
        * @return {string} note name
        * @private
        */
        private getNoteName_();
        /**
         * Set a custom number of keys for this field.
         * @param {number} nkeys Number of keys for this block,
         *     or 26 to use default.
         * @return {!Blockly.FieldNote} Returns itself (for method chaining).
         */
        setNumberOfKeys(size: number): FieldNote;
        onHtmlInputChange_(e: any): void;
        /**
         * Create a piano under the note field.
         */
        showEditor_(opt_quietInput?: boolean): void;
        /**
         * Callback for when the drop-down is hidden.
         */
        private onHide();
        /**
         * Close the note picker if this input is being deleted.
         */
        dispose(): void;
    }
}
declare namespace pxtblockly {
    interface FieldNumberDropdownOptions extends Blockly.FieldCustomDropdownOptions {
        min?: number;
        max?: number;
        precision?: any;
    }
    class FieldNumberDropdown extends Blockly.FieldNumberDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private menuGenerator_;
        constructor(value: number | string, options: FieldNumberDropdownOptions, opt_validator?: Function);
        getOptions(): string[][];
    }
}
declare namespace pxtblockly {
    class FieldProcedure extends Blockly.FieldDropdown {
        constructor(funcname: string, opt_validator?: Function);
        getOptions(): string[][];
        init(): void;
        setSourceBlock(block: Blockly.Block): void;
        getValue(): string;
        setValue(newValue: string): void;
        /**
         * Return a sorted list of variable names for procedure dropdown menus.
         * Include a special option at the end for creating a new function name.
         * @return {!Array.<string>} Array of procedure names.
         * @this {pxtblockly.FieldProcedure}
         */
        dropdownCreate(): string[][];
        onItemSelected(menu: any, menuItem: any): void;
    }
}
declare namespace pxtblockly {
    interface StyleOptions extends Blockly.FieldCustomOptions {
        bold: boolean;
        italics: boolean;
    }
    class FieldStyledLabel extends Blockly.FieldLabel implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(value: string, options?: StyleOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    interface FieldTextDropdownOptions extends Blockly.FieldCustomOptions {
        values: any;
    }
    class FieldTextDropdown extends Blockly.FieldTextDropdown implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(text: string, options: FieldTextDropdownOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    class FieldTextInput extends Blockly.FieldTextInput implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(value: string, options: Blockly.FieldCustomOptions, opt_validator?: Function);
    }
}
declare namespace pxtblockly {
    class FieldToggle extends Blockly.FieldNumber implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        private params;
        private state_;
        private checkElement_;
        private toggleThumb_;
        protected CURSOR: string;
        private type_;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        init(): void;
        getDisplayText_(): string;
        getTrueText(): string;
        getFalseText(): string;
        updateWidth(): void;
        getInnerWidth(): number;
        getMaxLength(): number;
        getOutputShape(): number;
        /**
         * Return 'TRUE' if the toggle is ON, 'FALSE' otherwise.
         * @return {string} Current state.
         */
        getValue(): string;
        /**
         * Set the checkbox to be checked if newBool is 'TRUE' or true,
         * unchecks otherwise.
         * @param {string|boolean} newBool New state.
         */
        setValue(newBool: string): void;
        switchToggle(newState: boolean): void;
        updateTextNode_(): void;
        render_(): void;
        /**
         * Toggle the state of the toggle.
         * @private
         */
        showEditor_(): void;
        private toVal(newState);
        private fromVal(val);
    }
}
declare namespace pxtblockly {
    class FieldToggleHighLow extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleOnOff extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleUpDown extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
    class FieldToggleDownUp extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldToggleYesNo extends FieldToggle implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        constructor(state: string, params: Blockly.FieldCustomOptions, opt_validator?: Function);
        getTrueText(): string;
        getFalseText(): string;
    }
}
declare namespace pxtblockly {
    class FieldTsExpression extends Blockly.FieldTextInput implements Blockly.FieldCustom {
        isFieldCustom_: boolean;
        /**
         * Same as parent, but adds a different class to text when disabled
         */
        updateEditable(): void;
    }
}
declare namespace pxtblockly {
    namespace svg {
        function hasClass(el: SVGElement, cls: string): boolean;
        function addClass(el: SVGElement, cls: string): void;
        function removeClass(el: SVGElement, cls: string): void;
    }
    function parseColour(colour: string | number): string;
    namespace AudioContextManager {
        function mute(mute: boolean): void;
        function stop(): void;
        function frequency(): number;
        function tone(frequency: number): void;
    }
}
